<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>test</title>
<style>
  .square{
    width: 150px;
    height: 150px;
    background-color: gold;
    margin-left: 300px;
    animation: test 6s infinite cubic-bezier(0.57, -0.5, 0.43, 1.53);
  }
  @keyframes test{
    0%, 50%{
      transform:  translateX(-30px);
    }
    70%, 100% {
      transform:  translateX(-200px);
    }
  }
  .parent{
    width: 200px;
    height: 100px;
    border: 5px solid #fe5958;
    position: relative;
  }
  .item{
    width: 0;
    height: 0;
    position: absolute;
    left: 50%;
    transform: translate(-50%);
    border-left: 20px solid transparent;
    border-right: 20px solid transparent;
  }
  .top{
    bottom: -20px;
    border-top: 20px solid #fe5958;
  }
  .bottom{
    bottom:  -13px;
    border-top: 20px solid #fff;
  }
  .is_embed {
    width: 100px;
    height: 100px;
  }
  .inline_father {
    font-size: 0;
    margin-top: 20px;
  }
  .inline_son {
    width: 100px;
    height: 100px;
    display: inline-block;
    background-color: #fe5958;
    font-size: 12px;
  }
  .change_color {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    margin-top: 20px;
  }

  .test_grid {
    width: 300px;
    height: 300px;
    border: 1px solid #000;
  }
  .grid_parent {
    display: grid;
    /* grid-template-columns: repeat(3, auto); */
    grid-template-columns: 1fr 2fr 1fr;
    grid-template-rows: repeat(4, 50px);
    /* grid-row-gap: 10px;
    grid-column-gap: 10px; */
    /* grid-gap: 10px 15px; */
    /* justify-content: center; */
    align-content: center;

    /* justify-items: stretch; */
    /* align-items: center; */
  }
  .grid_item {
    /* text-align: center; */
    background-color: yellow;
    border: 1px solid red;
/*       align-self: center;
    justify-self: center; */
  }
  .grid_item_1, .grid_item_2 {
    grid-column-start: 1;
    grid-column-end: 3;
  }
	.text-justify {
		width: 200px;
	}
	.text-justify p {
		text-align: justify;
		/* text-align-last: justify;	text-align-last: justify; 可直接使用此属性则不用使用伪类，但存在兼容性问题 */
		margin: 0;
	}
	.text-justify p:after {
		content: '';
		display: inline-block;
		width: 100%;
	}
	.set-cursor {
		cursor: not-allowed;
		/*cursor: no-drop;*/
		pointer-events: all;
	}
	.ao, .tu {
		display: inline-block;
		width: 0;
		margin: 10px 40px;
	}
	.tu {
		direction: rtl;
	}
	.ao:before, .tu:before {
		outline: 2px solid red;
		color: transparent;
	}
	.ao:before {
		content: 'love我love';
	}
	.tu:before {
		content: '我love我';
	}
	.test-counter {
		counter-reset: test 3;
		counter-increment: test;
		color: red;
		font-size: 16px;
	}
	.test-counter:before {
		content: counter(test);
	}
  .icon-menu {
    display: inline-block;
    width: 140px;
    height: 10px;
    padding: 35px 0;
    border-top: 10px solid;
    border-bottom: 10px solid;
    border-color: currentColor;
    background-color: currentColor;
    background-clip: content-box;
  }
  .icon-circle {
    display: inline-block;
    width: 60px;
    height: 60px;
    padding: 10px;
    border-radius: 50%;
    border: 10px solid currentColor;
    background-color: currentColor;
    background-clip: content-box;
  }
  .icon-menu-2 {
    display: inline-block;
    width: 100px;
    height: 10px;
    border-top: 30px double;
    border-bottom: 10px solid;
  }
  .add-icon {
    display: inline-block;
    width: 76px; height: 76px;
    border: 2px dashed;
    color: #ccc;
    text-indent: -20em;
    overflow: hidden;
    position: relative;
    transition: color .2s;
  }
  .add-icon::before, .add-icon::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
  }
  .add-icon::before {
    width: 20px;
    border-top: 4px solid;
    margin: -2px 0 0 -10px;
  }
  .add-icon::after {
    height: 20px;
    border-left: 4px solid;
    margin: -10px 0 0 -2px;
  }
  .add-icon:hover {
    color: #34538b;
  }
  .loading {
    width: 40px;
    height: 40px;
    border: 4px solid rgba(0, 0, 0, .1);
    border-left-color: #7983ff;
    border-radius: 50%;
    display: inline-block;
    animation: loading 1s linear infinite;
  }
  @keyframes loading {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }


</style>

</head>
<body>
  <style style="display: block;" contenteditable="true">
    .online_edit {
      color: red;
    }
  </style>
  <p class="online_edit">真的可以编辑吗？</p>
  <div class="loading"></div>
  <div class="square">123</div>
  <!-- 气泡框 -->
  <div class="parent">
    <div class="top item"></div>
    <div class="bottom item"></div>
  </div>
  <!-- H5进度条 -->
  <progress value="66" max="100" style="margin-top: 20px;"></progress>
  <embed src="share.jpg" class="is_embed" type="">
  <!-- 测试 inline-block -->
  <div class="inline_father">
    <div class="inline_son">去除display:</div>
    <div class="inline_son">inline-block间隙</div>
  </div>
  <!-- 测试简单版防抖 -->
  <p class="debounce" style="user-select: none;">你再点一下试试！</p>
  <div class="change_color"></div>

  <div class="test_grid">
    <div class="grid_parent">
      <div class="grid_item grid_item_1">11</div>
      <div class="grid_item grid_item_2">22</div>
      <div class="grid_item grid_item_3">33</div>
      <div class="grid_item grid_item_4">44</div>
      <div class="grid_item grid_item_5">55</div>
      <div class="grid_item grid_item_6">66</div>
      <div class="grid_item grid_item_7">77</div>
      <div class="grid_item grid_item_8">88</div>
      <div class="grid_item grid_item_9">99</div>
    </div>
  </div>

  <div class="text-justify">
		<p>文本</p>
		<p>这是文本</p>
		<p>这真的是文本</p>
  </div>

  <label>
		<input type="checkbox" disabled="true" class="set-cursor">
		鼠标禁用样式
  </label>

  <div class="ao-and-tu">
		<p class="ao"></p>
		<p class="tu"></p>
  </div>

	<p class="test-counter"></p>

  <i class="icon-menu"></i>
  <i class="icon-circle"></i>
  <i class="icon-menu-2"></i>

  <a class="add-icon" href="javascript:void(0)" title="继续上传">添加图片</a>
  
  








  <script src="G:\360Downloads\jquery-3.3.1.min.js"></script>
  <script>
  



// var i = 2;
// Number.prototype.valueOf = function() {
//   return i++;
// }
// var a = new Number(42);  // a 类型为object
// console.log(a);
// if (a == 2 && a == 3) {  // object 与 Number 非严格判断相等，会调用 object 的 valueOf 方法，此时已被重写
//   console.log('nani??')
// }


// for (var i = 1; i <= 5; i++) {
//   (function() {
//     var i = i;   // i 形参为undefined，无此声明，则会打印5次6（eventloop）
//     setTimeout(function timer() {
//       console.log(i)    // 打印5次undefined， 因为在IIFE内声明i；执行阶段i为undefined，被赋值给i，所以i的值仍为undefined
//     }, i * 1000)
//   })();
// }


// function setUrl(o) {
//   o.siteUrl = 'http://www.baidu.com';
//   o = new Object();
//   o.siteUrl = 'http://www.google.com';
// }
// let webSite = new Object();
// setUrl(webSite);
// console.log(webSite)    // {siteUrl: 'http://www.baidu.com'}，形参指向被更改，所以再次修改不会影响值函数外实参


// // 软绑定
// if (!Function.prototype.softBind) {
//   Function.prototype.softBind = function(obj) {
//     var fn = this;
//     var curried = [].slice.call( arguments, 1 );
//     var bound = function() {
//       return fn.apply( (!this || this === (window || global)) ? obj : this, curried.concat.apply( curried, arguments ) )
//     }
//     bound.prototype = Object.create( fn.prototype )
//     return bound;
//   }
// }
// function foo() {
//   console.log('name:' + this.name)
// }
// var obj = {name: 'obj'}, obj2 = {name: 'obj2'}, obj3 = {name: 'obj3'};
// var fooOBJ = foo.softBind(obj);
// fooOBJ();    // obj
// obj2.foo = foo.softBind(obj);
// obj2.foo();    // obj2
// fooOBJ.call(obj3);   // obj3
// setTimeout(obj2.foo, 10);    // obj


// function fn(a) {
//   let sum = a * a;
//   function count(b) {
//     sum += b * b
//     count.value = (function() {
//       return sum;
//     })();
//     return count;
//   }
//   count.value = (function() {  // IIFE 确保调用value属性直接获得结果
//     return sum;
//   })();
//   return count;
// }
// console.log(fn(1).value, 'value')
// console.log(fn(1)(2).value, 'value')
// console.log(fn(1)(2)(3).value, 'value')
// console.log(fn(1)(2)(3)(4).value, 'value')


// var bar = true;
// console.log(bar + 0); // 1
// console.log(bar + 'xyz'); // truexyz
// console.log(bar + true);  // 2
// console.log(bar + false); // 1
// console.log('1' > bar); // false
// console.log(1 + '2' + false); // 12false
// console.log('2' + ['koala', 1]); // 2koala,1
// var obj1 = {
//   a: 1,
//   b: 2
// }
// console.log('2' + obj1); // 2[Object Object]
// var obj2 = {
//   toString: function() {
//     return 'a'
//   }
// }
// console.log('2' + obj2); // 2a


// var arr1 = [1, 3, 5, 7, 9]
// arr1.reduce((x, y) => (console.log(x, y), x), 0)


// let list =[
//   { id:1, name:'部门A', parentId:0 },
//   { id:2, name:'部门B', parentId:0 },
//   { id:3, name:'部门C', parentId:1 },
//   { id:4, name:'部门D', parentId:1 },
//   { id:5, name:'部门E', parentId:2 },
//   { id:6, name:'部门F', parentId:3 },
//   { id:7, name:'部门G', parentId:2 },
//   { id:8, name:'部门H', parentId:4 }
// ];
// function convert(list) {
//   const res = [];
//   const map = list.reduce((res, v) => (res[v.id] = v, res), {});
//   console.log('map', map);
//   for (const item of list) {
//     if (item.parentId === 0) {
//       res.push(item);
//       continue;
//     }
//     if (item.parentId in map) {
//       const parent = map[item.parentId];
//       parent.children = parent.children || [];
//       item.children = item.children || [];
//       parent.children.push(item);
//     }
//   }
//   return res;
// }
// console.log(convert(list));


// var aa = {}, bb = {key: '123'}, cc = {key: '456'};
// aa[bb] = 'b';
// aa[cc] = 'c';
// console.log(aa[bb])   // c   当键名不是string或symbol 的时候（如为对象），会将键名String()，此时aa[bb]与aa[cc]的键名都为'[object Object]'，所有将会进行覆盖，所以打印c



// 字符串大小写取反
// function setStr(str) {
//   var newStr = str.split('').map(x => {return x === x.toUpperCase()? x.toLowerCase() : x.toUpperCase()}).join('');
//   return newStr
// }


// 设计一个lazy类
// Hi I am ***
// 等待n秒         sleepFirst插至任务队列最前
// I am eating ***
// I am eating ***
// 等待n秒         sleep顺序执行
// I am eating ***
// class LazyMan {
//   constructor(name) {
//     this.taskList = [];
//     this.name = name;
//     console.log(`Hi I am ${this.name}`);
//     setTimeout(() => {
//       this.next();
//     }, 0)
//   }
//   eat(name) {
//     var that = this;
//     var fn = (function(n) {
//       return function() {
//         console.log(`I am eating ${n}`)
//         that.next();
//       }
//     })(name);
//     this.taskList.push(fn);
//     return this
//   }
//   sleepFirst(time) {
//     var that = this;
//     var fn = (function(t) {
//       return function() {
//         setTimeout(() => {
//           console.log(`等待了${t}秒...`)
//           that.next();
//         }, t * 1000);
//       }
//     })(time);
//     this.taskList.unshift(fn);
//     return this;
//   }
//   sleep(time) {
//     var that = this;
//     var fn = (function(t) {
//       return function() {
//         setTimeout(() => {
//           console.log(`等待了${t}秒...`)
//           that.next();
//         }, t * 1000);
//       }
//     })(time);
//     this.taskList.push(fn);
//     return this;
//   }
//   next() {
//     var fn = this.taskList.shift();
//     fn && fn();
//   }
// }
// function lazy(name) {
//   return new LazyMan(name);
// }
// lazy('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');


// // 找出对称数
// var arr1 = [...Array(9999).keys()].map(x => x + 1).filter(x => {return String(x).length > 1 && x === Number(String(x).split('').reverse().join(''))});
// console.log(arr1);


// var obj = {
//   '1': 222,
//   '2': 111,
//   '5': 888,
//   '12': 666
// };
// var arr = Array.from({length: 12}).map((ele, index) => obj[index + 1] === void 0? null : obj[index + 1]);
// var arr = Array.from({length: 12}, (f, index) => {return obj[index + 1] === void 0? null : obj[index + 1]});
// console.log(arr);


// function currying(fn, length) {
//   length = length || fn.length;
//   return function(...args) {
//     console.log(...args, length, args, 'aaaa');
//     return args.length >= length? fn.apply(this, args) : currying(fn.bind(this, ...args), length - args.length);
//   }
// }
// const fn = currying(function(a, b, c) {
//   console.log([a, b, c]);
// })
// fn('a', 'b');
// fn('a', 'b')('c');
// fn('a')('b')('c');
// fn('a')('b', 'c');


// const toStr = Function.prototype.call.bind(Object.prototype.toString);


// var longArr = [];
// for (let i = 0; i < 100000000; i++) {
//   longArr[i] = i
// };
// var start1 = +new Date();
// for(let i = 0; i < longArr.length; i++) {
//   longArr[i] = i
// }
// console.log('正序循环耗时：%s ms', Date.now() - start1, longArr.length);
// var start11 = +new Date();
// for(let i = 0, len = longArr.length; i < len; i++) {
//   longArr[i] = i;
// }
// console.log('正序循环赋值长度：%s ms', Date.now() - start11, longArr.length);    // 使用变量存储数组长度，性能与倒序相近
// var start2 = +new Date();
// for(let i = longArr.length - 1; i > -1; i--) {
//   longArr[i] = i
// }
// console.log('倒序循环耗时：%s ms', Date.now() - start2, longArr.length);   // 性能优于正序，如在正序中定义length，不需每次循环都获取length，可优化性能，与倒序for差不多
// var start3 = +new Date();
// var arrr = [];
// arrr = longArr.map(item => arrr.push(item));
// console.log('map耗时：%s ms', Date.now() - start3, arrr.length )   // 数据过大时性能比正序for循环还差


// outer: for(let i = 0; i < 5; i++) {
//   console.log('i', i)
//   inner: for(let j = 0; j < 3; j++) {
//     if (j === 1) {
//       continue outer;
//     }
//     console.log('j', j)
//   }
// }


// var start1 = +new Date();
// var str1 = "I'm a thirty-five character string.", newStr1 = '', appends1 = 5000000;
// while(appends1--) {
//   newStr1 += str1;
// }
// var time1 = Date.now() - start1;
// console.log('直接拼接耗时：' + time1 + 'ms');
// var start2 = +new Date();
// var str2 = "I'm a thirty-five character string.", newStr2 = '', strs = [], appends2 = 5000000;
// while(appends2--) {
//   strs[strs.length] = str2;
// }
// newStr2 = strs.join('');
// var time2 = Date.now() - start2;
// console.log('数组产出耗时：' + time2 + 'ms');    // 性能优于直接拼接


// console.log(Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON);
// var aa = {
//   valueOf: () => { console.log('valueOf'); return {} },
//   toString: () => { console.log('toString'); return {} }
// }
// aa[Symbol.toPrimitive] = () => { console.log('Primitive'); return 'hello' }
// console.log(aa + '');


// setTimeout(() => console.log('d'), 0)
// var r = new Promise(function(resolve, reject) {
//   resolve()
// })
// r.then(() => {
//   var begin = Date.now();
//   while(Date.now() - begin < 1000);
//   console.log('c1');
//   new Promise(function(resolve, reject) {
//     resolve()
//   }).then(() => console.log('c2'))
// })


// function sleep(duration) {
//   return new Promise(function(resolve, reject) {
//     setTimeout(resolve, duration);
//   })
// }
// async function changeColor(duration, color) {
//   $('.change_color').css('background', color);
//   await sleep(duration);
// }
// async function main() {
//   while(true) {
//     await changeColor(3000, 'green');
//     await changeColor(1000, 'yellow');
//     await changeColor(2000, 'red');
//   }
// }
// main();


// function foo() {
//   try {
//     return 0;
//   } catch(err) {

//   } finally {
//     console.log('a')
//     return 1;
//   }
// }
// console.log(foo())    // a  0  先执行try，遇到return，则先执行finally，如finally里有return语句，则会覆盖try中的return，不会再执行try里的return，打印函数执行函数的toString()



// 监听复制行为，通过“Ctrl + c” 或点击右键进行复制
document.addEventListener('copy', function(event) {
  setClipboardText(event);
})
// 复制行为后的数据处理
function setClipboardText(event) {
  // 获取选中的内容
  var selectText;
  if (window.getSelection) {
    selectText = window.getSelection().toString();
  } else {
    selectText = document.selection.createRange().text;
  }
  // 设置剪切板的内容
  if (event.clipboardData) {
    event.clipboardData.setData('text/html', "你就只会'Ctrl + c' 和 'Ctrl + v' 吗？");
    event.clipboardData.setData('text/plain', "你就只会'Ctrl + c' 和 'Ctrl + v' 吗？");
  } else if (window.clipboardData) {
    window.clipboardData.setData('text', "你就只会'Ctrl + c' 和 'Ctrl + v' 吗？");
  }
  event.preventDefault();
}



// 获取屏幕像素比，（物理像素与CSS像素）一个CSS像素的大小相对于一个物理像素的大小的比值
// console.log(window.devicePixelRatio)


// var aa = 1;
// function foo() {
//   console.log(aa);    // undefined，虽然if语句永远不会执行，但在预处理阶段，var穿透了if层，所以还是undefined
//   if (false) {
//     var aa = 2;
//   }
// }
// foo();


// var aa = 1;
// function foo() {
//   var o = { aa: 3 };
//   with(o) {
//     var aa = 2;      // 建议不要使用with
//   }
//   console.log(o.aa);    // 2
//   console.log(aa);    // undefined
// }
// foo();


// console.log(foo);   // undefined，此处函数声明仍会被提升及初始化，但不会被赋值
// if (true) {
//   function foo() { }
// }
// if (true) {
//   console.log(foo);   // 此处函数声明会被提升、初始化及赋值
//   function foo() { }
// }


// var aa = [];
// aa.push({id: 1, value: '11'}, {id: 2, value: '22'});
// console.log(aa);


// var a = {
//   name: 'xiaoming',
//   other: {
//     height: 180,
//     age: 18,
//     sex: 'woman',
//     weight: '70kg'
//   }
// };
// var b = JSON.parse(JSON.stringify(a));
// var b = Object.assign({}, a);
// console.log(a, b);
// a.name = 'kangkang';
// a.other.age = 28;
// console.log(a, b);


// var a = {n: 1};
// var b = a;
// a = a.x = {n: 2};
// a.n = 3;
// console.log(a, 'aaaaaa');   // {n: 3}
// console.log(b, 'bbbbbb');    // {n: 1, x: {n: 3}}


// var data = [];
// for (let i = 0; i < 3; i++) {
//   data[i] = function() {
//     console.log(i);
//   };
// }
// data[0]();    // 0
// data[1]();    // 1
// data[2]();    // 2


// function foo() {
//   // "use strict"
//   console.log(this.a);
// }
// var a = 2;
// foo();       // 严格模式下 undefined
// (function(){
//   "use strict"
//   foo();
// })();        // 严格模式下 undefined


// console.log(fun);        //报错 **** is not defined
// console.log(person);     //报错 **** is not defined


// function foo() {
//   console.log(this.a);
// }
// function doFoo(fn) {
//   fn();
// }
// var obj = {
//   a: 2,
//   foo: foo
// };
// var bar = obj.foo;
// var a = "oops, global";
// obj.foo();    // 2
// bar();    // 'oops, global'
// doFoo( obj.foo );   // 'oops, global'


// function foo() {
//   console.log(this.a);
// }
// var obj = { a: 2 };
// foo.call( obj );    // 2


// function foo(something) {
//   console.log(this.a, something);
//   return this.a + something;
// }
// var obj = { a: 2 };
// var bar = foo.bind( obj );
// var b = bar(3);   // 2  3
// console.log(b);   // 5


// var a = 654321;
// function foo() {
//   var a = 123456;
//   console.log(this.a);   //654321
//   foo2();
// }
// function foo2() {
//   console.log(this.a, 'aa');   //654321
//   foo3();
// }
// function foo3() {
//   console.log(this.a, 'aaaa');   //654321, 'aaaa'
// }
// foo();


// function foo(el) {
//   console.log(el, this.id);
// }
// var obj = {
//   id: 'awesome'
// }
// var arr = [1, 2, 3];
// arr.forEach(foo, obj);   // 传入的第二个参数，为this的指向
// arr.map(foo, obj);   // 传入的第二个参数，为this的指向


// function foo(a) {
//   console.log(a ,'aaa')
// }
// var b = new foo(2)
// console.log(b);    // {}


// var arr = [1, 2, 3, 4, 5]
// var arr_2 = [].shift.apply({0: 1, 1: 2, 2: 3, 3: 4, 4: 5, length: 5});   // 1
// var arr_3 = Array.prototype.slice.call({0: 1, 1: 2, 2: 3, 3: 4, 4: 5, length: 5});   // [1, 2, 3, 4, 5]
// console.log(arr_2)
// console.log(arr_3)


// function foo() {
//   var arr = [].slice.apply(arguments, [1, 2])
//   var bar = arr.concat.apply(arr, [4])
//   // 相当于 var arr = [].slice.call(arguments, 1, 2)
//   console.log(arr)
//   console.log(bar)
// }
// foo(1, 2, 3)    //[2] and [2,4]


// var a = 'hello';
// function foo() {
//   // console.log(this.a)
//   console.log(this)       // {}
//   this.a = 'world'
//   console.log(this)       // {a: 'world'}
// }
// var bar = new foo()       // {},  {a: 'world'}
// bar.b = 'hey'
// console.log(bar)          // {a: 'world', b: 'hey'}


// var num = 1;
// var myObject = {
//   num: 2,
//   add: function() {
//     this.num = 3;
//     (function() {
//       console.log(this.num);
//       this.num = 4;
//     })();
//     console.log(this.num);
//   },
//   sub: function() {
//     console.log(this.num)
//   }
// }
// myObject.add();   // 1  3
// console.log(myObject.num);    // 3
// console.log(num);     // 4
// var sub = myObject.sub;
// sub();    // 4


// var name = 'window'
// var person1 = {
//   name: 'person1',
//   show1: function() {
//     console.log(this.name)
//   },
//   show2: () => console.log(this.name),
//   show3: function() {
//     return function() {
//       console.log(this.name)
//     }
//   },
//   show4: function() {
//     return () => console.log(this.name)
//   }
// }
// var person2 = { name: 'person2' }

// person1.show1()   // person1，隐式绑定，指向person1，
// person1.show1.call(person2)   // person2, 显式绑定，指向person2

// person1.show2()   // window    // 箭头函数绑定，this指向外层作用域，即全局作用域
// person1.show2.call(person2)   // window   箭头函数的this无法通过bind  call  apply来直接修改（改变作用域中this的指向可以改变箭头函数的this）

// person1.show3()()   // window，默认绑定，这是一个高阶函数，调用者是window，类似于var func = person1.show3()并执行func
// person1.show3().call(person2)   // person2
// person1.show3.call(person2)()   // window，默认绑定，调用者是window

// person1.show4()()   // person1
// person1.show4().call(person2)   // person1
// person1.show4.call(person2)()   // person2


// var arr_1 = ['a', 'b'];
// var arr_2 = ['c', 'd'];
// var arr_3 = arr_1.concat(arr_2);
// Array.prototype.push.apply(arr_1, arr_2);
// console.log(arr_3);  // ['a', 'b', 'c', 'd']
// console.log(arr_1);  // ['a', 'b', 'c', 'd']  apply 为将参数打包后传入，所以实际 push 是单个 push，若改为 call，则结果为['a', 'b', ['c', 'd']]


// function idArray(obj) {
//   console.log(Object.prototype.toString.call(obj))        // '[object Array]'
//   console.log(obj.toString())          // '1,2,3'
// }
// idArray([1, 2, 3])


// function foo() {
//   console.log('arguments：', arguments)
//   let arr_1 = Array.from(arguments);
//   let arr_2 = Array.prototype.slice.apply(arguments);
//   let arr_3 = [].slice.call(arguments);
//   let arr_4 = [...arguments];
//   console.log('arr_1：', arr_1);
//   console.log('arr_2：', arr_2);
//   console.log('arr_3：', arr_3);
//   console.log('arr_4：', arr_4);
// }
// foo(1, 2, 3, 4);


// // 1、赋值语句是右执行的,此时会先执行右侧的对象
// var obj = {
//   // 2、say 是立即执行函数
//   say: function() {
//       function _say() {
//           // 5、输出 window
//           console.log(this);
//       }
//       // 3、编译阶段 obj 赋值为 undefined
//       console.log(obj);
//       // 4、obj是 undefined，bind 本身是 call实现，
//       // 【进阶3-3期】：call 接收 undefined 会绑定到 window。
//       return _say.bind(obj);
//   }(),
// };
// obj.say();


// var obj = Object.create(null);
// obj.a = 'a'
// console.log(obj)       // {a: 'a'}

// var obj_2 = {
//   b: 'b'
// }
// console.log(obj_2)        // { b: 'b' }

// Object.prototype.c = 'c'
// console.log('c' in obj_2)       // true
// console.log('c' in obj)        // false
// console.log(obj.hasOwnProperty('a'));       // 报错，使用Object.create(null)创建的对象无法使用此方法，需使用下面的方法，应该该对象没有连接至Object.prototype
// console.log(obj_2.hasOwnProperty('c'));       // false
// console.log(Object.prototype.hasOwnProperty.call(obj, 'a'));        // true
// console.log(Object.prototype.hasOwnProperty.call(obj_2, 'c'))       // false


// function add(a) {
//   function sum(b) {
//     console.log(b)        // 2  3  4
//     a = a + b;
//     return sum;
//   }
//   sum.toString = function() {
//     return a
//   }
//   return sum
// }
// console.log(add(1)(2)(3)(4))       // 10   打印函数时会自动调用函数的toString()方法


// console.log((new Date()).valueOf())
// var a = '1';
// var b = Object(a);
// console.log(b);       // { '1' }，可通过b[0]获取值1（字符串1）
// var c = { n: 1, m: 2}
// var d = Object.assign(b, c);
// console.log(d)    // { '1', n: 1, m: 2}         b === d
// console.log(d[0])   // 字符串1


// var str = 'hello world'
// var str_1 = str.slice(0, 5)
// var str_2 = str.substring(0, 5)
// console.log('str_1', str_1)       // 'hello'
// console.log('str_2', str_2)       // 'hello'


// var arr = [1, 4, [3, 4, [6, 2, 3, 5, [6, 8, 3, 7, '1', '2']]]]
// var flat_arr = arr.flat(Infinity)    // 扁平化
// var set_arr = new Set(flat_arr)      // 去重（伪数组）
// var from_arr = Array.from(set_arr)   // 转为真数组
// var sort_arr = from_arr.sort((a, b) => { return a - b } )    // 排序
// console.log('flat_arr', flat_arr)
// console.log('set_arr', set_arr)
// console.log('from_arr', from_arr)
// console.log('sort_arr', sort_arr)


// console.log(isNaN(parseInt('a', 10)))       // true


// var arr_1 = ['a', 'b', 'c', 'd', 'e'];
// var arr_2 = ['e', 'd', 'f', 'x', 'b'];
// arr_1 = arr_1.filter(function(x) {
//   return arr_2.every(function(y) {
//     return y !== x
//   })
// })
// console.log(arr_1)   // ['a', 'c']


// function sum(a, b) {
//   arguments[1] = 3;
//   console.log(arguments[1]);    // 3，两者可以互相改变
// }
// sum(1, 2);


// function fn (a){
//   console.log(a);   // function()，函数声明提升至最先，改变了传入的arguments，此时arguments[0] === 123，函数声明
//   var a = 123;
//   console.log(a);   // 123，a被赋值
//   function a (){};
//   console.log(a);   // 123，a最初已被赋值为函数，后被赋值为123，后续没有再次赋值
//   var b = function (){}
//   console.log(b);   // function，函数表达式
// }
// fn(1);


// 1, 7, 6, 8, 2, 4, 3, 5, 9, 11, 10, 12
// console.log('1');
// setTimeout(
//   function(){
//     console.log('2');
//     process.nextTick(function(){
//       console.log('3');
//     })
//     new Promise(function(resolve){
//       console.log('4');
//       resolve();
//     }).then(function(){
//       console.log('5')
//     })
//   })
// process.nextTick(function(){
//   console.log('6');
// })
// new Promise(function(resolve){
//   console.log('7');
//   resolve();
// }).then(function(){
//   console.log('8')
// })
// setTimeout(function(){
//   console.log('9');
//   process.nextTick(function(){
//     console.log('10');
//   })
//   new Promise(function(resolve){
//     console.log('11');
//     resolve();
//   }).then(function(){
//     console.log('12')
//   })
// })


// 快速排序
// var arr = [4, 9, 456, 213, 798, 125, 8, 3, 78, 325, 215, 951, 12, 778, 347, 432, 56, 546, 132];
// var quictSort = function(arr) {
//   if (arr.length <= 1) {
//     return arr
//   }
//   var pivotIndex = Math.floor(arr.length / 2);
//   var pivot = arr.splice(pivotIndex, 1)[0];
//   var left = [];
//   var right = [];
//   for (var i = 0; i < arr.length; i++) {
//     if (arr[i] < pivot) {
//       left.push(arr[i])
//     } else {
//       right.push(arr[i])
//     }
//   }
//   return quictSort(left).concat([pivot], quictSort(right))
// }
// console.log(quictSort(arr));
// 选择排序（取出数组中最小值，放至首位或末尾，再次取剩下值得最小值，放至第二或倒数第二位，依次循环）
// 冒泡排序（两两对比，互换位置，依次循环）


// // 普通版冒泡排序
// function bubbleSort1(array) {
//   console.time();
//   if (!Array.isArray(array)) {
//     throw new Error('需传入一个数组');
//   }
//   if (array.length <= 1) {
//     return array;
//   }
//   let arr = array;
//   for (let i = 0, len1 = arr.length; i < len1; i++) {
//     for (let j = 0, len2 = arr.length - i - 1; j < len2; j++) {
//       if (arr[j] > arr[j + 1]) {
//         // const temp = arr[j];
//         // arr[j] = arr[j + 1];
//         // arr[j + 1] = temp;
//         [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
//       }
//     }
//   }
//   console.timeEnd();
//   return arr;
// }
// // 改进版冒泡排序  （将最大值放至最右后，将本轮最后一个操作位置作为下一轮的终点，可以减少不必要的冒泡）
// function bubbleSort2(array) {
//   console.time();
//   if (!Array.isArray(array)) {
//     throw new Error('需传入一个数组');
//   }
//   let arr = array;
//   let i = arr.length - 1;
//   while(i > 0) {
//     let pos = 0;
//     for (let j = 0; j < i; j++) {
//       if (arr[j] > arr[j + 1]) {
//         pos = j;
//         // const temp = arr[j];
//         // arr[j] = arr[j + 1];
//         // arr[j + 1] = temp;
//         [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
//       }
//     }
//     i = pos;
//   }
//   console.timeEnd();
//   return arr;
// }
// const initialArr = Array.from({length: 1000}, () => Math.ceil(Math.random() * 10000));
// const sortArr1 = bubbleSort1(initialArr);   // 普通版
// const sortArr2 = bubbleSort2(initialArr);   // 改进版
// console.log(sortArr1);
// console.log(sortArr2);


// var now = +new Date();
// console.log(now)    // 当前时间戳

// var time = new Date().valueOf()
// console.log(time)   // 当前时间戳

// var time_2 = Date.now();
// console.log(time_2)   // 当前时间戳


// for (var i = 0; i < 3; i++) {
//   setTimeout(function() {
//     console.log(i)
//   }, 1000)
// }
// console.log(i)    // 打印一次3， 1秒后再打印3次3


// var arr = [1, 2, 3];
// fun(arr);
// console.log(arr);   // [1, 2, 3]
// function fun(a) {
//   a = []    // 可能：传入实参，将值复制一份，赋值给函数定义时的形参，此时形参改变，不会影响实参的值（函数定义时形参，调用时传入实参，将值复制赋值给形参）
// }


// var b = 10;
// (function b(){
//   // 内部作用域，会先查找是否已有变量 b 的声明，确实是有的，发现了具名函数 function b(){}，拿此 b 进行赋值
//   // 但 IIFE 无法进行赋值（内部机制，类似 const 定义的常量），所以无效，严格模式下会报错
//   // 'use strict'  // 报错
//   b = 20;
//   console.log(b);
// })();   // 打印 b 函数

// var a = 10;
// (function () {
//   console.log(a);
//   a = 5;
//   console.log(window.a);
//   var a = 20;
//   console.log(a);
// })();


// // 改写 Object 的 toString / valueOf 方法，改写 Array 的 join() 方法，利用 Object.defineProperty 的 get 方法，使a递增
// let a = {
//   i: 1,
//   toString () {
//     return a.i++
//   }
// }
// let aa = [1, 2, 3]
// aa.join = aa.shift
// if(aa == 1 && aa == 2 && aa == 3) {
//   console.log(1);
// }


// async function async1() {
//   console.log('acync1 start');
//   await async2();   // async 返回一个promise
//   console.log('async1 end')
// }
// async function async2() {
//   console.log('async2')
// }

// console.log('script start');

// setTimeout(function() {
//   console.log('setTimeout')
// }, 0)

// async1();

// new Promise(function(resolve) {
//   console.log('promise1');
//   resolve();
// }).then(function() {
//   console.log('promise2')
// });
// console.log('script end')
// script start  >>>  acync1 start  >>>  async2  >>>   promise1   >>>   script end    >>>   async1 end   >>>   promise2   >>>   setTimeout


// var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];
// var arr_2 = Array.from(new Set(arr.flat(Infinity))).sort((a, b) => { return a - b });   // 数组扁平化、去重、升序


// for (var i = 0; i < 10; i++) {
//   ((i) => {
//     setTimeout(() => {
//       console.log(i)
//     }, 1000)
//   })(i)
// }    // 打印 0 - 9
// for (let i = 0; i < 10; i++) {
//   setTimeout(() => {
//     console.log(i)
//   }, 1000)
// }    // 打印 0 - 9
// for (var i = 0; i < 10; i++) {
//   setTimeout((i) => {
//     console.log(i)
//   }, 1000, i)
// }    // 打印 0 - 9


// a 的值为什么情况下，可以打印出 1
// var a = ?;
// 利用 Object 的 toString
// let a = {
//   i: 1,
//   toString() {
//     return a.i++
//   }
// }
// 利用 Object 的 valueOf
// let a = {
//   i: 1,
//   valueOf() {
//     return a.i++
//   }
// }
// 利用 Array 的 toString() 隐式调用 join()
// var a = [1, 2, 3];
// a.join = a.shift;
// if (a == 1 && a == 2 && a == 3) {
//   console.log(1)
// }


// console.log([] == ![])    // true !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// console.log(undefined == null)    // true


// 防抖（简单版）
// function debounce(fn) {
//   let a = null;
//   console.log(a);
//   return function() {
//     clearTimeout(a);
//     a = setTimeout(() => {
//       fn.call(this, arguments);
//     }, 500)
//   }
// }
// function haha() {
//   console.log('hahahaha')
// }
// var _debounce = document.getElementsByClassName('debounce')[0];
// _debounce.addEventListener('click', debounce(haha), false);

// 防抖 ——————>> 进化版
function debounce_2(func, wait = 50, imediate = true) {
  let timer, context, args;
  // 定义延迟执行函数
  const later = () => setTimeout(() => {
    // 延迟函数执行完毕，清空缓存的定时器序号
    timer = null;
    // 延迟执行的情况下，函数会在延迟函数中执行
    // 使用到之前缓存的参数和上下文
    if (!imediate) {
      func.call(context, args);
      context = args = null;
    }
  }, wait);

  // 这里返回的函数是每次实际调用的函数
  return function(...params) {
    // 如果没有创建延迟执行函数 later ，就创建一个
    if (!timer) {
      timer = later();
      // 如果是立即执行，调用函数
      // 否则缓存参数和调用上下文
      if (imediate) {
        func.call(this, params);
      } else {
        context = this;
        args = params;
      }
    } else {
      // 如果已有延迟执行函数 later，调用的时候清除原来的，并重新设定一个
      clearTimeout(timer);
      timer = later();
    }
  }
}
function haha() {
  console.log('hahahaha'); 
}
var _debounce_2 = document.getElementsByClassName('debounce')[0];
_debounce_2.addEventListener('click', debounce_2(haha, 300, true), false);


// function testAsync() {
//   var a = 0;
//   var b = async () => {
//     a = a + await 10;
//     console.log('2', a);
//     a = (await 10) + a;
//     console.log('3', a)
//   };
//   b();
//   a++
//   console.log('1', a)
// }
// testAsync();    // 1 1     2 10       3 20


// 传入一个int类型，输出该值的string类型的倒序，要求使用递归
// function reverseNum(num) {
//   let num1 = Math.floor(num / 10);
//   let num2 = num % 10;
//   if (num1 > 0) {
//     return `${num2}${reverseNum(num1)}`
//   } else {
//     return `${num}`
//   }
// }
// console.log(reverseNum(1234))    // 4321


// function Foo() {
//   Foo.a = function() {
//     console.log(1)
//   }
//   this.a = function() {
//     console.log(2)
//   }
// }
// Foo.prototype.a = function() {
//   console.log(3)
// }
// Foo.a = function() {
//   console.log(4)
// }
// Foo.a();    // 4  此刻构造函数Foo还产生实例，所以还没有被执行，调用的是最后定义的Foo.a（Foo的直接方法），所以打印出4
// let obj = new Foo();    // 此刻Foo被实例化，构造方法Foo.a覆盖了最后定义的那个全局Foo.a
// obj.a();    // 2    由于有直接方法，无需调用原型上的方法，所以打印出2
// Foo.a();    // 1    构造方法已经替换了全局Foo上的方法，所以打印出1


// function commafy(num) {
//   return num && num
//     .toString()
//     .replace(/(\d)(?=(\d{3})+\.)/g, function($0, $1) {
//     return $1 + ",";
//   });
// }
// console.log(commafy(1234567.90));    //1,234,567.90


// console.log(~~2.9)   // 类似 parseInt 且效率更高  正数相当于Math.floor()    负数相当于Math.ceil()
// console.log(-2.9 | 0)    //  正数相当于Math.floor()    负数相当于Math.ceil()


// function Foo(n) {
//   this.name = n || 'foo_01';
//   for (var i = 0; i < 3; i++) {
//     setTimeout(function() {
//       console.log(i, this.name)
//     }, 0)
//     console.log(i)
//   }
// }
// var obj = new Foo();    // 0, 1, 2
// console.log(obj.name);    // foo_01   此时微任务定时器：3  '' 三次（window.name值为空字符串）


// console.log(new Date('2011/11/11'));
// console.log(new Date('2011-11-11'));	// 使用'-'链接的日期字符串为错误格式，所以会自动多出 8 小时，
// console.log(null >= 0);	// true


// 解构赋值
// let arr = [1, 2, 3, 4, 5, 6, 7];
// [arr[1], arr[5]] = [arr[5], arr[1]];
// console.log(arr);


// const nest = (list, id = null, link = 'parent_id') => list.filter(item => item[link] === id).map(item => ({ ...item, children: nest(list, item.id) }));
// const comments = [
//   { id: 1, parent_id: null },
//   { id: 2, parent_id: 1 },
//   { id: 3, parent_id: 1 },
//   { id: 4, parent_id: 2 },
//   { id: 5, parent_id: 4 },
//   { id: 6, parent_id: 1 },
// ];
// const nestedComments = nest(comments);
// console.log(nestedComments);


// console.log((new Date('2011/11/11 11:11:11')).toTimeString().slice(0, 8)); // '11:11:11'


// function pxToRem() {
// 	const baseSize = 100;
// 	function setRem() {
// 		let scale = document.documentElement.clientWidth / 750;
// 		document.documentElement.style.fontSize = ( baseSize * Math.min( scale , 2 )) + 'px';
// 	}
// 	// 初始化
// 	setRem();
// 	// 改变窗口大小时重新设置rem
// 	window.onresize = function() {
// 		setRem();
// 	}
// }


// let arr = [1, 3, 5, 7, 9];
// console.log(arr.includes(9)); // includes 用来判断数组中是否包含某个元素


// let arr = Array(10).fill(0);  // Array(length) 创建数组，fill(item) 初始化每项的值


// new Promise((resolve, reject) => {
//   setTimeout(() => {
//     resolve({ test: 1 })
//   }, 1000)
// }).then((data) => {
//   console.log('result1', data)
//   //dosomething
//   return test()
// }).then((data) => {
//   console.log('result2', data)
// })

// function test(id) {
//   return new Promise(((resolve) => {
//     setTimeout(() => {
//       resolve({ test: 2 })
//     }, 5000)
//   }))
// }


// async function fn() {
//   return 66;    // async函数返回的是一个 promise
// }
// fn().then(res => {
//   console.log(res);  // 66 async用于声明一个 function 是异步的，而 await 用于等待一个异步方法完成，
// })


// // 创建websocket.js
// const WSS_URL = `wss://wss.xxxx.com/ws?appid=xxx`;
// let Socket = '';
// let setIntervalWesocketPush = null;

// /**建立连接 */
// export function createSocket() {
//   if (!Socket) {
//     console.log('建立websocket连接');
//     Socket = new WebSocket(WSS_URL);
//     Socket.onopen = onopenWS;
//     Socket.onmessage = onmessageWS;
//     Socket.onerror = onerrorWS;
//     Socket.onclose = oncloseWS;
//   } else {
//     console.log('websocket已连接');
//   }
// }
// /**打开WS之后发送心跳 */
// export function onopenWS() {
//   sendPing(); //发送心跳
// }
// /**连接失败重连 */
// export function onerrorWS() {
//   clearInterval(setIntervalWesocketPush);
//   Socket.close();
//   createSocket(); //重连
// }
// /**WS数据接收统一处理 */
// export function onmessageWS(e) {
//   // EventTarget.dispatchEvent 向一个指定的实践目标派发一个事件，并以合适的顺序同步调用目标元素相关的事件处理函数
//   // new CustomEvent() 构造方法用于创建一个事件对象
//   window.dispatchEvent(new CustomEvent('onmessageWS', {
//     detail: {
//       data: e
//     }
//   }))
// }
// /**发送数据
//  * @param eventType
//  */
// export function sendWSPush(eventTypeArr) {
//   const obj = {
//     appId: 'airShip',
//     cover: 0,
//     event: eventTypeArr
//   }
//   if (Socket !== null && Socket.readyState === 3) {
//     Socket.close();
//     createSocket(); //重连
//   } else if (Socket.readyState === 1) {
//     Socket.send(JSON.stringify(obj));
//   } else if (Socket.readyState === 0) {
//     setTimeout(() => {
//       Socket.send(JSON.stringify(obj))
//     }, 3000)
//   }
// }
// /**关闭WS */
// export function oncloseWS() {
//   clearInterval(setIntervalWesocketPush);
//   console.log('websocket已断开');
// }
// /**发送心跳 */
// export function sendPing() {
//   Socket.send('ping');
//   setIntervalWesocketPush = setInterval(() => {
//     Socket.send('ping');
//   }, 5000);
// }
// // 调用
// import { createSocket, sendWSPush } from './api/websocket';

// createSocket(); //创建
// sendWSPush(11111); //发送数据

// //监听ws数据响应
// const getDataFunc = function(e) {
//   console.log(e.detail.data);
// } 
// window.addEventListener('onmessageWS', getDataFunc);

// //根据需要，销毁事件监听
// window.removeEventListener('onmessageWS', getDataFunc);


let data = [{
	"name": "数据源",
	"children": [{
		"name": "广东",
		"children": [{
			"name": "广州",
			"children": [{
				"name": "天河区"
			}, {
				"name": "越秀区"
			}, {
				"name": "白云区"
			}]
		}, {
			"name": "深圳",
			"children": [{
				"name": "福田"
			}]
		}, {
			"name": "汕头",
			"children": [{
				"name": "龙湖"
			}, {
				"name": "金平"
			}]
		}]
	}, {
		"name": "湖南",
		"children": [{
			"name": "长沙"
		}, {
			"name": "岳阳"
		}]
	}]
}];
// 广度遍历, 创建一个执行队列, 当队列为空的时候则结束
function getName2(data) {
    let result = [];
    let queue = data;
    while (queue.length > 0) {
        [...queue].forEach(child => {
            queue.shift();
            result.push(child.name);
            child.children && (queue.push(...child.children));
        });
    }
    return result.join(',');
}

console.log(getName2(data));
// a,b,a1,a2,a3,b1,b2,b3,a11,a12,a21,a22,a31,a32,b11,b12,b21,b22,b31,b32



// 继承
  // 原型链继承
  // 缺点：   原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。
  // function SuperType() {
  //   this.property = true;
  // }
  // SuperType.prototype.getSuperValue = function() {
  //   return this.property;
  // }
  // function subType() {
  //   this.subproperty = false;
  // }
  // subType.prototype = new SuperType();
  // subType.prototype.getSubValue = function() {
  //   return this.subproperty;
  // }
  // var instance = new subType();
  // console.log(instance.getSuperValue());    // true


  // 借用构造函数继承
  // 缺点：   只能继承父类的实例属性和方法，不能继承原型属性/方法       无法实现复用，每个子类都有父类实例函数的副本，影响性能
  // function SuperType() {
  //   this.colors = ["red", "blue", "green"];
  // }
  // function SubType() {
  //   SuperType.call(this);
  // }
  // var instance1 = new SubType();
  // instance1.colors.push('block');
  // console.log(instance1.colors);   // ["red", "blue", "green", "block"]
  // var instance2 = new SubType();
  // console.log(instance2.colors);    // ["red", "blue", "green"]


  // 组合继承（综合以上两种方法）
  // 缺点:    调用了两次SuperType()，其原型中会存在两份相同的属性/方法
  // function SuperType(name) {
  //   this.name = name;
  //   this.colors = ["red", "blue", "green"];
  // }
  // SuperType.prototype.sayName = function() {
  //   console.log(this.name);
  // }
  // function SubType(name, age) {
  //   // 继承属性（第二次调用）
  //   SuperType.call(this, name);
  //   this.age = age;
  // }
  // SubType.prototype = new SuperType();    // 继承方法，构建原型链（第一次调用）
  // SubType.prototype.constructor = SubType;    // 重写SubType.prototype的constructor属性，指向自己的构造函数SubType
  // SubType.prototype.sayAge = function() {
  //   console.log(this.age);
  // }
  // var instance1 = new SubType('Nicholas', 29);
  // instance1.colors.push('block');
  // console.log(instance1.colors);
  // instance1.sayName();
  // instance1.sayAge();
  // var instance2 = new SubType('Greg', 27);
  // console.log(instance2.colors);
  // instance2.sayName();
  // instance2.sayAge();


  // 原型式继承（利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型）
  // 缺点：   原型链继承多个实例的引用类型属性指向相同，存在篡改的可能        无法传递参数
  // function object(obj) {
  //   // 传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象
  //   function F() {};
  //   F.prototype = obj;
  //   return new F();
  // }
  // var person = {
  //   name: 'Nicholas',
  //   friends: ["Shelby", "Court", "Van"]
  // };
  // var anotherPerson = object(person);
  // anotherPerson.name = 'Greg';
  // anotherPerson.friends.push('Rob');
  // var yetAnotherPerson = object(person);
  // yetAnotherPerson.name = 'Linda';
  // yetAnotherPerson.friends.push('Barbie');
  // console.log(person.friends);


  // 寄生式继承（在原型式继承的基础上，增强对象，返回构造函数）
  // 缺点： ===== 同原型式继承
  // function object(obj) {
  //   // 传入其中的对象执行了一次浅复制，将构造函数F的原型直接指向传入的对象
  //   function F() {};
  //   F.prototype = obj;
  //   return new F();
  // }
  // function createAnother(original) {
  //   var clone = object(original);
  //   clone.sayHi = function() {
  //     console.log('Hi');
  //   }
  //   return clone;
  // }
  // var person = {
  //   name: 'Nicholas',
  //   friends: ["Shelby", "Court", "Van"]
  // };
  // var anotherPerson = createAnother(person);
  // anotherPerson.sayHi();


// 寄生组合式继承（结合借用构造函数传递参数和寄生模式实现继承）
// 这是最成熟的方法，也是现在库实现的方法
// function inheritPrototype(subType, superType) {
//   var prototype = Object.create(superType.prototype);   // 创建对象，创建父类原型的一个副本
//   prototype.constructor = subType;      // 增强对象，弥补因重写原型而失去的默认的constructor 属性
//   subType.prototype = prototype;      // 指定对象，将新创建的对象赋值给子类的原型
// }
// function SuperType(name) {
//   this.name = name;
//   this.colors = ["red", "blue", "green"];
// }
// SuperType.prototype.sayName = function() {
//   console.log(this.name);
// }
// function subType(name, age) {
//   SuperType.call(this, name);
//   this.age = age;
// }
// inheritPrototype(subType, SuperType);     // 将父类原型指向子类
// subType.prototype.sayAge = function() {
//   // 新增子类原型属性
//   console.log(this.age);
// }
// var instance1 = new subType('xyc', 23);
// var instance2 = new subType('lxy', 13);
// instance1.colors.push('2');     // ["red", "blue", "green", "2"]
// instance2.colors.push('3');     // ["red", "blue", "green", "3"]



// call 模拟实现
// Function.prototype.call1 = function(context) {
//   context = context? Object(context) : window;
//   context.fn = this;
//   let args = [...arguments].slice(1);
//   let result = context.fn(...args);
//   delete context.fn;
//   return result;
// }


// apply 模拟实现
// Function.prototype.apply1 = function(context, arr) {
//   context = context? Object(context) : window;
//   context.fn = this;
//   let result;
//   if (arr) {
//     result = context.fn(...arr);
//   } else {
//     result = context.fn();
//   }
//   delete context.fn;
//   return result;
// }


// var obj1 = {
//   '2': 3,
//   '3': 4,
//   'length': 2,
//   'splice': Array.prototype.splice,
//   'push': Array.prototype.push
// };
// obj1.push(1);
// obj1.push(2);
// console.log(obj1);    // obj1 有 length 属性，实际为类数组，push 方法会根据 length 改变数组的长度，obj1['2'] = 1, obj1['3'] = 2, length = 4


// 给定两个数组，获取两个数组的交集
// 思路：用 hash 表存 arr1 中的元素及出现的次数，判断 arr2 中是否有 hash 表中的元素，有则存到结果数组中，并将 hash 表中的出现次数减一，时间复杂度（m + n）
// const intersect  = (arr1, arr2) => {
//   const result = [];
//   const map = {};
//   // 存放 arr1 中的元素及出现的次数
//   for (let i of arr1) {
//     if (map[i]) {
//       map[i]++
//     } else {
//       map[i] = 1
//     }
//   }
//   // 判断 arr2 中是否有对应元素，有则存储并将次数减一
//   for (let j of arr2) {
//     if (map[j] > 0) {
//       result.push(j);
//       map[j]--
//     }
//   }
//   return result;
// }
// const arr1 = [1, 3, 5, 7, 9, 1, 3, 1, 5, 1, 7, 1, 2, 4, 6, 8, 10];
// const arr2 = [1, 1, 1, 3, 8, 10, 11, 13, 6, 6, 7];
// const result = intersect(arr1, arr2);
// console.log(result);


// // 将数组处理为 [ [1, 3, 5], [10, 18], [33, 38], [86, 89]] 格式
// // 生成一个随机数组，并去重、排序
// let arr = Array.from({length: 10}, () => Math.ceil(Math.random() * 100));
// arr = [...(new Set(arr))].sort((a, b) => a - b);
// const obj = {};
// arr.map(item => {
//   let key = Math.floor(item / 10);
//   obj[key] = [...(obj[key] || []), item];
// })
// let result = [];
// for (let k in obj) {
//   result.push(obj[k]);
// }


// 改造函数，使之打印 0 - 99 或 99 - 0
// 原函数
// function print(n) {
//   setTimeout(() => {
//     console.log(n);
//   }, Math.floor(Math.random() * 1000));
// }
// 方式1
// function print(n) {
//   setTimeout((() => {
//     console.log(n);
//   }).call(null), Math.floor(Math.random() * 1000));
// }
// 或
// function print(n) {
//   setTimeout((() => {
//     console.log(n);
//     return () => {};    // 立即执行函数新增返回值，防止报错
//   })(), Math.floor(Math.random() * 1000));
// }
// 方式二（方式三：直接新增定时时间参数，随机数作为第三个参数）
// function print(n) {
//   setTimeout(console.log(n), Math.floor(Math.random() * 1000));
// }
// for (var i = 0; i < 100; i++) {
//   print(i);
// }


// URLSearchParams 实例方法：has  get  getAll  append  set 等等...
// let url1 = 'https://www.xx.cn/api?keyword=111&level1=&local_batch_id=&elective=&local_province_id=33';
// let url2 = 'https://www.xx.cn/api?keyword=222&level1=&local_batch_id=&elective=800&local_province_id=33';
// let url3 = 'https://www.xx.cn/api?keyword=333&level1=&local_batch_id=&elective=800,700&local_province_id=33';
// // 当需通过 URLSearchParams 查询 ? 后的第一个参数时，传入完整的 url 是无法解析并获取到的
// // 可通过将 url 实例化，即通过 new URL(url)，返回一个实例对象，取对象的 search 属性，传入 URLSearchParams 即可正常使用
// const search1 = new URLSearchParams(url1);
// console.log(search1.get('keyword'));   // null，因为查询的是 ? 后的第一个参数
// console.log(search1.has('keyword'));    // false 同上
// // 处理url
// url1 = new URL(url1);
// const search2 = new URLSearchParams(url1.search);
// console.log(search2.get('keyword'));    // 111
// console.log(search2.has('keyword'));    // true


// 从大数组中取一定个数的不重复随机数   Math.random() 取 0(包含) - 1(不包含) 间的随机数
// 以下两种方式性能差不多，耗时几毫秒
// 测试一
// const randomNumHandle = (len, randomNum) => {
//   let originArr = Array.from({length: len}, (v, i) => i + 1);
//   let resultSet = new Set();
//   console.time();
//   for (let i = 0; i < randomNum; i++) {
//     addNum();
//   }
//   function addNum() {
//     let luckDog = Math.floor(Math.random() * len);
//     if (!resultSet.has(originArr[luckDog])) {
//       resultSet.add(originArr[luckDog]);
//     } else {
//       addNum();
//     }
//   }
//   console.timeEnd();
//   return Array.from(resultSet);
// }
// const arr = randomNumHandle(100000, 10000);
// console.log(arr);
// 测试二
// 取一个随机数，加入结果数组后，将其与原数组当次遍历的最后一个元素互换位置，开始下次遍历，下次遍历时遍历长度减一，不再遍历已被添加的元素
// function shuffle(arr, size) {
//   console.time();
//   let result = [];
//   for (let i = 0; i < size; i++) {
//     let randomIndex = Math.floor(Math.random() * (arr.length - i));
//     const item = arr[randomIndex];
//     result.push(item);
//     arr[randomIndex] = arr[arr.length - 1 - i];
//     arr[arr.length - 1 - i] = item;
//   }
//   console.timeEnd();
//   return result;
// }
// const arr1 = Array.from({length: 100000}, (v, i) => i + 1);
// const result = shuffle(arr1, 10000);
// console.log(result);


// 将数组处理为：连续递增元素采用 ~ 分隔简化
// function simplifyStr(arr) {
//   if (!Array.isArray(arr)) {
//     throw new Error('需传入一个数组');
//   }
//   // 去重、正序排序
//   arr = [...new Set(arr)].sort((a, b) => a - b);
//   let result = [];
//   let initialVal = arr[0];
//   arr.forEach((val, idx) => {
//     if (val + 1 !== arr[idx + 1]) {
//       if (val === initialVal) {
//         result.push(val);
//       } else {
//         result.push(`${initialVal}~${val}`)
//       }
//       initialVal = arr[idx + 1];
//     }
//   })
//   return result;
// }
// const arr = Array.from({length: 20}, () => Math.ceil(Math.random() * 30));
// console.log(simplifyStr(arr).join(','));


// var entry = {
//   a: {
//     b: {
//       c: {
//         dd: 'abcdd'
//       }
//     },
//     d: {
//       xx: 'adxx'
//     },
//     e: 'ae'
//   }
// }
// function flatObj(obj, key = '', result = {}) {
//   for (let k in obj) {
//     if (obj.hasOwnProperty(k)) {
//       let keyName = `${key}${k}`;
//       if (typeof obj[k] === 'object') {
//         flatObj(obj[k], keyName + '.', result);
//       } else {
//         result[keyName] = obj[k];
//       }
//     }
//   }
//   return result;
// }
// let entryResult = flatObj(entry);
// console.log(entryResult);
// // 将处理后的对象，重新处理还原为原对象
// function processResult(result) {
//   const obj = Object.create(null);
//   for (let key in result) {
//     const keyArr = key.split('.');
//     setObj(obj, keyArr, result[key]);
//   }
//   return obj;
// }
// function setObj(obj, keyArr, val) {
//   if (!obj[keyArr[0]]) obj[keyArr[0]] = Object.create(null);
//   let tmp = obj[keyArr[0]];
//   for (let i = 1; i < keyArr.length; i++) {
//     if (!tmp[keyArr[i]]) tmp[keyArr[i]] = i === keyArr.length - 1? val : Object.create(null);
//     tmp = tmp[keyArr[i]];
//   }
// }
// const entry2 = processResult(entryResult);
// console.log(entry2);
// // 还原方法二：
// function processResult2(entry) {
//   const keys = Object.keys(entry);
//   let resultObj = Object.create(null);
//   for (let key of keys) {
//     let keyArr = key.split('.');
//     keyArr.reduce((prev, next, index, arr) => {
//       prev[next] = prev[next] || Object.create(null);
//       if (index === arr.length - 1) prev[next] = entry[key];
//       return prev[next];
//     }, resultObj);
//   }
//   return resultObj;
// }
// const entry3 = processResult2(entryResult);
// console.log(entry3);


// // 柯里化
// const curry = (fn, ...args) => {
//   console.log(...args, 'aaa');
//   return args.length < fn.length? (...arguments) => curry(fn, ...args, ...arguments) : fn(...args)
// };

// function test(a, b, c) {
//   return a + b + c;
// }
// var sum = curry(test, 6);
// console.log(sum(1, 2), '666');


// // 找出字符串中 “连续” 出现次数最多的字符和个数
// const str1 = 'abcaakjbb';
// const str2 = 'abbkejsbcccwqaa';
// const arr1 = str1.match(/(\w)\1*/g);   // ['a', 'b', 'c', 'aa', 'k', 'j', 'bb'];
// const arr2 = str2.match(/(\w)\1*/g);  //  ["a", "bb", "k", "e", "j", "s", "b", "ccc", "w", "q", "aa"] 
// const maxLen1 = Math.max(...arr1.map(item => item.length));
// const maxLen2 = Math.max(...arr2.map(item => item.length));
// const result1 = arr1.reduce((pre, curr) => {
//   if (curr.length === maxLen1) {
//     pre[curr[0]] = curr.length;
//   }
//   return pre;
// }, {});     // { a: 2, b: 2 }
// const result2 = arr2.reduce((pre, curr) => {
//   if (curr.length === maxLen2) {
//     pre[curr[0]] = curr.length;
//   }
//   return pre;
// }, {});     // { c: 3 }
// console.log(result1, result2, 'mmm');












    </script>
  </body>
</html>
